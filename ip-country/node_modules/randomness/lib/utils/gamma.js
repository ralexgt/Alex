"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gammaincc = exports.gammainc = exports.complimentaryIncompleteGamma = exports.lowerIncompleteGamma2 = void 0;
const mathjs_1 = require("mathjs");
const gamma = (n) => (0, mathjs_1.gamma)(n);
const upperIncompleteGamma = (a, x, d = 0, iterations = 100) => {
    if (d == iterations) {
        if (d % 2 == 1) {
            return 1;
        }
        else {
            const m = d / 2;
            return x + (m - a);
        }
    }
    if (d == 0) {
        return (x ** a * Math.E ** -x) / upperIncompleteGamma(a, x, (d = d + 1));
    }
    else if (d % 2 == 1) {
        const m = 1 + (d - 1) / 2;
        return x + (m - a) / upperIncompleteGamma(a, x, (d = d + 1));
    }
    else {
        const m = d / 2;
        return 1 + m / upperIncompleteGamma(a, x, (d = d + 1));
    }
};
const upperIncompleteGamma2 = (a, x, d = 0, iterations = 100) => {
    if (d == iterations)
        return 1;
    if (d == 0)
        return (x ** a * Math.E ** -x) / upperIncompleteGamma2(a, x, (d = d + 1));
    const m = d * 2 - 1;
    return m - a + x + (d * (a - d)) / upperIncompleteGamma2(a, x, (d = d + 1));
};
const lowerIncompleteGamma = (a, x, d = 0, iterations = 100) => {
    if (d == iterations) {
        if (d % 2 == 1) {
            return 1;
        }
        else {
            const m = d / 2;
            return x + (m - a);
        }
    }
    if (d == 0) {
        return (x ** a * Math.E ** -x) / lowerIncompleteGamma(a, x, (d = d + 1));
    }
    else if (d % 2 == 1) {
        const m = d - 1;
        const n = (d - 1) / 2;
        return a + m - ((a + n) * x) / lowerIncompleteGamma(a, x, (d = d + 1));
    }
    else {
        const m = d - 1;
        const n = d / 2;
        return a + m + (n * x) / lowerIncompleteGamma(a, x, (d = d + 1));
    }
};
const lowerIncompleteGamma2 = (a, x) => gamma(a) - upperIncompleteGamma2(a, x);
exports.lowerIncompleteGamma2 = lowerIncompleteGamma2;
const complimentaryIncompleteGamma = (a, x) => 1 - upperIncompleteGamma(a, x);
exports.complimentaryIncompleteGamma = complimentaryIncompleteGamma;
const gammainc = (a, x) => lowerIncompleteGamma(a, x) / gamma(a);
exports.gammainc = gammainc;
const gammaincc = (a, x) => upperIncompleteGamma(a, x) / gamma(a);
exports.gammaincc = gammaincc;
//# sourceMappingURL=gamma.js.map